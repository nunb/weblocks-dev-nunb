# HG changeset patch
# User nunb <nunb@tallinn>
# Date 1258906788 -3600
# Node ID a25c651e29011a88d24756230ea633461ab9c9eb
# Parent  ba5a806c2b82b272af31b3e2df3b05dec1783c75
Minor things mostly: allow multiple dialogs, add rel attribute, and bring in jwr's version of form view utils from latest weblocks-dev

diff -r ba5a806c2b82 -r a25c651e2901 src/control-flow/dialog.lisp
--- a/src/control-flow/dialog.lisp	Thu Nov 05 11:35:21 2009 +0100
+++ b/src/control-flow/dialog.lisp	Sun Nov 22 17:19:48 2009 +0100
@@ -78,15 +78,16 @@
 (defun/cc do-dialog (title callee &key css-class close)
   (declare (special *on-ajax-complete-scripts*))
   (if (ajax-request-p)
-      (prog2
-	  (when (current-dialog)
-	    (error "Multiple dialogs not allowed."))
-	  (call callee (lambda (new-callee)
+      (cond
+	  ((current-dialog)
+	    (warn "Multiple dialogs not allowed."))
+	  (t
+	   (call callee (lambda (new-callee)
 			 (setf (current-dialog) (make-dialog :title title
 							     :widget new-callee
 							     :close close
 							     :css-class css-class))
-                         (send-script (ps* (make-dialog-js title new-callee css-class close)))))
+                         (send-script (ps* (make-dialog-js title new-callee css-class close))))))
 	(setf (current-dialog) nil)
         (send-script (ps (remove-dialog))))
       (do-modal title callee :css-class css-class)))
diff -r ba5a806c2b82 -r a25c651e2901 src/snippets/html-utils.lisp
--- a/src/snippets/html-utils.lisp	Thu Nov 05 11:35:21 2009 +0100
+++ b/src/snippets/html-utils.lisp	Sun Nov 22 17:19:48 2009 +0100
@@ -253,10 +253,10 @@
     (:span :class "close-button"
 	   (render-link close-action (humanize-name button-string)))))
 
-(defun render-input-field (type name value &key id class maxlength style)
+(defun render-input-field (type name value &key id class maxlength style rel)
   (with-html
     (:input :type type :name (attributize-name name) :id id
-	    :value value :maxlength maxlength :class class
+	    :value value :maxlength maxlength :class class :rel rel
             :style style)))
 
 (defun render-password (name value &key (id (gen-id)) (class "password") maxlength style
diff -r ba5a806c2b82 -r a25c651e2901 src/views/view/utils.lisp
--- a/src/views/view/utils.lisp	Thu Nov 05 11:35:21 2009 +0100
+++ b/src/views/view/utils.lisp	Sun Nov 22 17:19:48 2009 +0100
@@ -3,9 +3,10 @@
 
 (export '(find-view field-info field-info-field field-info-object
 	  field-info-path get-object-view-fields map-view-fields
-	  map-mixin-fields count-view-fields obtain-view-field-value
-	  render-object-view class-from-view render-view
-	  render-object-view-impl attributize-presentation))
+	  find-field-info find-view-field map-mixin-fields
+	  count-view-fields obtain-view-field-value render-object-view
+	  class-from-view render-view render-object-view-impl
+	  attributize-presentation attributize-view-field-name))
 
 ;;; View rendering utils
 (defun find-view (view &optional (signal-error-p t))
@@ -33,6 +34,84 @@
 if it was mixed into the view."
   field object parent-info)
 
+(defun inserting-custom-fields (obj proc custom-fields)
+  "Wrap PROC, a `map-view-fields' candidate, with a variant that
+inserts each of CUSTOM-FIELDS as defined by `get-object-view-fields'.
+Secondary, answer a termination thunk."
+  (unless custom-fields
+    (return-from inserting-custom-fields (values proc (constantly nil))))
+  (multiple-value-bind (posned-customs end-customs)
+      (partition custom-fields #'consp)
+    (setf posned-customs (stable-sort posned-customs #'< :key #'car))
+    (let ((posn -1))
+      (labels ((custom-field->field-info (custom-field)
+		 (etypecase custom-field
+		   (field-info custom-field)
+		   (view-field (make-field-info :field custom-field
+						:object obj
+						:parent-info nil))))
+	       (wrapper (vfield-info)
+		 (incf posn)
+		 (loop while (and posned-customs
+				  (<= (caar posned-customs) posn))
+		       do (funcall proc (custom-field->field-info
+					 (cdr (pop posned-customs))))
+			  (incf posn))
+		 (funcall proc vfield-info)))
+	(values #'wrapper
+		(f0 (mapc (compose #'wrapper #'custom-field->field-info)
+			  end-customs)
+		    (mapc (compose proc #'custom-field->field-info #'cdr)
+			  posned-customs)))))))
+
+(defun %map-object-view-fields (proc obj view-designator
+				&key include-invisible-p (expand-mixins t)
+				custom-fields &allow-other-keys)
+  "Implement `get-object-view-fields', except for consing up the
+result list, instead calling PROC on each resulting `field-info'."
+  (labels ((map-level-fields (proc view)
+	     (let ((view (or (and view (find-view view))
+			     (return-from map-level-fields))))
+	       (map-level-fields proc (view-inherit-from view))
+	       (dolist (vfield (view-fields view))
+		 (funcall proc vfield))))
+	   (map-level (obj view mixin-container)
+	     (let ((vfields (make-hash-table :test 'eq)))
+	       ;; prefer latest
+	       (map-level-fields
+		(f_ (setf (gethash (view-field-slot-name _) vfields) _))
+		view)
+	       (map-level-fields
+		(lambda (vfield)
+		  ;; we only use the in-order vfield as a tag into the
+		  ;; vfields HT, taking first-instance-only
+		  (setf vfield (gethash (view-field-slot-name vfield) vfields))
+		  (when vfield
+		    (let ((vfield-info (make-field-info
+					:field vfield :object obj
+					:parent-info mixin-container)))
+		      (etypecase vfield
+			(inline-view-field
+			   (when (or include-invisible-p
+				     (not (view-field-hide-p vfield)))
+			     (funcall proc vfield-info)))
+			(mixin-view-field
+			   (if expand-mixins
+			       (map-level
+				(and obj
+				     (or (obtain-view-field-value vfield obj)
+					 (funcall (mixin-view-field-init-form vfield))))
+				(mixin-view-field-view vfield) vfield-info)
+			       (funcall proc vfield-info)))))
+		    ;; avoid duplicates
+		    (remhash (view-field-slot-name vfield) vfields)))
+		view))))
+    (multiple-value-bind (wproc terminate-proc)
+	(inserting-custom-fields obj proc custom-fields)
+      (setf proc wproc)
+      (map-level obj view-designator nil)
+      (funcall terminate-proc))))
+
 (defun get-object-view-fields (obj view-designator &rest args
 			       &key include-invisible-p (expand-mixins t) custom-fields
 			       &allow-other-keys)
@@ -54,128 +133,48 @@
 Each custom field can be either a field-info structure or a
 view-field. Field-info structures are inserted as is, and view-fields
 are wrapped in field-info structures with common-sense defaults."
-  (declare (ignore args))
-  (labels ((compute-view-field-info-list  (view-designator obj parent-field-info)
-	     "Computes a full list of view fields, including inherited
-	     fields. Returns a list of field-infos."
-	     (let ((view (when view-designator
-			   (find-view view-designator))))
-	       (when view
-		 (append (compute-view-field-info-list
-			  (view-inherit-from view) obj
-			  parent-field-info)
-			 (mapcar (lambda (field)
-				   (make-field-info :field field :object obj
-						    :parent-info parent-field-info))
-				 (view-fields view))))))
-	   (factor-overriden-fields (field-info-list)
-	     "Overrides parent fields redefined in children."
-             ;(format t "fil: ~S~%" field-info-list)
-             (flet ((field-key (field-info &aux (field (field-info-field field-info)))
-                      (cons (view-field-slot-name field) (awhen (field-info-parent-info field-info)
-                                                              (view-field-slot-name (field-info-field IT)))))
-                    (parent (field-info &aux (field (field-info-field field-info)))
-                      (field-info-parent-info field-info))
-                    (mixin-p (field-info &aux (field (field-info-field field-info)))
-                      (typep field 'mixin-view-field)))
-               ;(format t "in: ~S~%" (mapcar (compose #'describe #'field-info-field) field-info-list))
-               (let* ((fields (remove-duplicates field-info-list :key #'field-key :from-end nil))
-                      (true-inline-fields (remove-duplicates fields :test #'equal
-                                                             :key (compose #'view-field-slot-name #'field-info-field)
-                                                             :from-end nil))
-                      (true-inline-fields (remove-if (lambda (fi) (or (parent fi) (mixin-p fi))) true-inline-fields
-                                                     :from-end t))
-                      (expanded-mixin-fields (remove-if-not (lambda (fi) (or (parent fi) (mixin-p fi)))
-                                                            fields))
-                      (expanded-mixin-fields (remove-duplicates expanded-mixin-fields :test #'equal :key #'field-key))
-                      (expanded-mixin-fields (remove-if (curry-after #'find true-inline-fields
-                                                                     :test #'equal :key (compose #'view-field-slot-name
-                                                                                                 #'field-info-field)
-                                                                     :from-end nil) expanded-mixin-fields))
-                      (merged-fields (sort (union true-inline-fields expanded-mixin-fields)
-                                           #'< :key (lambda (field)
-                                                      (flet ((pos (field where)
-                                                               (let ((r (position (field-key field) where :key #'field-key :test #'equal)))
-                                                               ;(format t "field: ~S / where: ~S -> ~S%" (field-key field)
-                                                               ;        (mapcar #'field-key where) r)
-                                                               r
-                                                               )))
-                                                        (let ((result (or (pos field fields)
-                                                                          (pos field true-inline-fields)
-                                                                          (pos field expanded-mixin-fields)
-                                                                          0)))
-                                                        #+(or)(format t "result for field ~A: ~A~%" field result) result))))))
-                 ;(format t "true inline: ~S~%" (mapcar #'field-key true-inline-fields))
-                 ;(format t "expanded ~S~%" (mapcar #'field-key expanded-mixin-fields))
-                 ;(format t "fields ~S~%" (mapcar #'field-key fields))
-                 ;(format t "merged ~S~%" (mapcar (compose #'describe #'field-info-field) merged-fields))
-                 merged-fields))) ; XXX this is quite inefficient (at least n^2 + n*log(n))
-	   (expand-mixin-fields (field-info-list)
-	     "Expands mixin fields into inline fields. Returns two
-              values - a list of expanded field-infos, and true if at
-              least one field has been expanded."
-	     (apply #'append
-		    (mapcar (lambda (field-info)
-			      (let ((field (field-info-field field-info))
-				    (obj (field-info-object field-info)))
-				(etypecase field
-				  (inline-view-field (list field-info))
-				  (mixin-view-field (when (or include-invisible-p
-							      (not (view-field-hide-p field)))
-						      (compute-view-field-info-list
-						       (mixin-view-field-view field)
-						       (when obj
-							 (or (obtain-view-field-value field obj)
-							     (funcall (mixin-view-field-init-form field))))
-						       field-info))))))
-			    field-info-list)))
-	   (custom-field->field-info (custom-field)
-	     (etypecase custom-field
-	       (field-info custom-field)
-	       (view-field (make-field-info :field custom-field
-					    :object obj
-					    :parent-info nil)))))
-    (let* ((initial-step (factor-overriden-fields
-			  (compute-view-field-info-list view-designator obj nil)))
-	   (results
-	    (if expand-mixins
-		(loop for field-info-list = initial-step
-		   then (factor-overriden-fields
-			 (expand-mixin-fields field-info-list))
-		   until (notany (lambda (field-info)
-				   (typep (field-info-field field-info) 'mixin-view-field))
-				 field-info-list)
-		   finally (return (if include-invisible-p
-				       field-info-list
-				       (remove-if #'view-field-hide-p field-info-list
-						  :key #'field-info-field))))
-		initial-step)))
-      (dolist (custom-field custom-fields results)
-	(if (consp custom-field)
-	    (insert-at (custom-field->field-info (cdr custom-field)) results (car custom-field))
-	    (push-end (custom-field->field-info custom-field) results))))))
+  (declare (ignore include-invisible-p expand-mixins custom-fields))
+  (let ((expansion '()))
+    (apply #'%map-object-view-fields
+	   (f_ (push _ expansion)) obj view-designator args)
+    (nreverse expansion)))
 
-(defun map-view-fields (fn view obj &rest args &key include-invisible-p custom-fields
-			&allow-other-keys)
+(defun map-view-fields (fn view obj &rest args)
   "Acts like mapcar for view fields. FN should expect a structure of
 type field-info."
-  (declare (ignore args))
-  (mapcar fn (get-object-view-fields obj view
-				     :include-invisible-p include-invisible-p
-				     :custom-fields custom-fields)))
+  (let ((expansion '()))
+    (apply #'%map-object-view-fields
+	   (f_ (push (funcall fn _) expansion)) obj view args)
+    (nreverse expansion)))
 
-(defun map-mixin-fields (fn view obj &rest args)
-  (mapc fn (remove-if
-	    (lambda (field-info)
-	      (not (typep (field-info-field field-info) 'mixin-view-field)))
-	    (apply #'get-object-view-fields obj view
-		   :expand-mixins nil args))))
+(defun find-field-info (name view obj &rest govf-args)
+  "Finds a field-info object by name and returns it."
+  (let (field)
+    (apply #'map-view-fields
+	   (lambda (fi)
+	     (when (equalp (view-field-slot-name (field-info-field fi))
+			   name)
+	       (setf field fi)))
+	   view obj govf-args)
+    field))
 
-(defun count-view-fields (view &key include-invisible-p custom-fields)
+(defun find-view-field (&rest args)
+  (let ((field-info (apply #'find-field-info args)))
+    (when field-info
+      (field-info-field field-info))))
+
+(defun map-mixin-fields (fn view obj &rest govf-args)
+  (apply #'%map-object-view-fields
+	 (lambda (field-info)
+	   (when (typep (field-info-field field-info) 'mixin-view-field)
+	     (funcall fn field-info)))
+	 obj view :expand-mixins nil govf-args))
+
+(defun count-view-fields (view &rest govf-args)
   "Counts the number of fields in a given view."
-  (length (get-object-view-fields nil view
-				  :include-invisible-p include-invisible-p
-				  :custom-fields custom-fields)))
+  (let ((count 0))
+    (apply #'%map-object-view-fields (f_% (incf count)) nil view govf-args)
+    count))
 
 (defun slot-reader (class slot-name)
   "Returns a reader, if one is defined, on the slot."
@@ -268,6 +267,14 @@
      presentation))
    "-presentation"))
 
+(defmethod attributize-view-field-name ((field-info field-info))
+  "Attributize a view field name from its FIELD-INFO structure."
+  (let ((parent-prefix (awhen (field-info-parent-info field-info)
+                              (view-field-slot-name (field-info-field it))))
+        (name (view-field-slot-name (field-info-field field-info))))
+    (when name
+      (attributize-name (format nil "~@[~A-~]~A" parent-prefix name)))))
+
 (defmethod print-object ((obj field-info) stream)
   (flet ((field-key (field-info &aux (field (field-info-field field-info)))
                     (cons (view-field-slot-name field) (awhen (field-info-parent-info field-info)
# HG changeset patch
# User nunb <nunb@tallinn>
# Date 1258906788 -3600
# Node ID a25c651e29011a88d24756230ea633461ab9c9eb
# Parent  ba5a806c2b82b272af31b3e2df3b05dec1783c75
Minor things mostly: allow multiple dialogs, add rel attribute, and bring in jwr's version of form view utils from latest weblocks-dev

diff -r ba5a806c2b82 -r a25c651e2901 src/control-flow/dialog.lisp
--- a/src/control-flow/dialog.lisp	Thu Nov 05 11:35:21 2009 +0100
+++ b/src/control-flow/dialog.lisp	Sun Nov 22 17:19:48 2009 +0100
@@ -78,15 +78,16 @@
 (defun/cc do-dialog (title callee &key css-class close)
   (declare (special *on-ajax-complete-scripts*))
   (if (ajax-request-p)
-      (prog2
-	  (when (current-dialog)
-	    (error "Multiple dialogs not allowed."))
-	  (call callee (lambda (new-callee)
+      (cond
+	  ((current-dialog)
+	    (warn "Multiple dialogs not allowed."))
+	  (t
+	   (call callee (lambda (new-callee)
 			 (setf (current-dialog) (make-dialog :title title
 							     :widget new-callee
 							     :close close
 							     :css-class css-class))
-                         (send-script (ps* (make-dialog-js title new-callee css-class close)))))
+                         (send-script (ps* (make-dialog-js title new-callee css-class close))))))
 	(setf (current-dialog) nil)
         (send-script (ps (remove-dialog))))
       (do-modal title callee :css-class css-class)))
diff -r ba5a806c2b82 -r a25c651e2901 src/snippets/html-utils.lisp
--- a/src/snippets/html-utils.lisp	Thu Nov 05 11:35:21 2009 +0100
+++ b/src/snippets/html-utils.lisp	Sun Nov 22 17:19:48 2009 +0100
@@ -253,10 +253,10 @@
     (:span :class "close-button"
 	   (render-link close-action (humanize-name button-string)))))
 
-(defun render-input-field (type name value &key id class maxlength style)
+(defun render-input-field (type name value &key id class maxlength style rel)
   (with-html
     (:input :type type :name (attributize-name name) :id id
-	    :value value :maxlength maxlength :class class
+	    :value value :maxlength maxlength :class class :rel rel
             :style style)))
 
 (defun render-password (name value &key (id (gen-id)) (class "password") maxlength style
diff -r ba5a806c2b82 -r a25c651e2901 src/views/view/utils.lisp
--- a/src/views/view/utils.lisp	Thu Nov 05 11:35:21 2009 +0100
+++ b/src/views/view/utils.lisp	Sun Nov 22 17:19:48 2009 +0100
@@ -3,9 +3,10 @@
 
 (export '(find-view field-info field-info-field field-info-object
 	  field-info-path get-object-view-fields map-view-fields
-	  map-mixin-fields count-view-fields obtain-view-field-value
-	  render-object-view class-from-view render-view
-	  render-object-view-impl attributize-presentation))
+	  find-field-info find-view-field map-mixin-fields
+	  count-view-fields obtain-view-field-value render-object-view
+	  class-from-view render-view render-object-view-impl
+	  attributize-presentation attributize-view-field-name))
 
 ;;; View rendering utils
 (defun find-view (view &optional (signal-error-p t))
@@ -33,6 +34,84 @@
 if it was mixed into the view."
   field object parent-info)
 
+(defun inserting-custom-fields (obj proc custom-fields)
+  "Wrap PROC, a `map-view-fields' candidate, with a variant that
+inserts each of CUSTOM-FIELDS as defined by `get-object-view-fields'.
+Secondary, answer a termination thunk."
+  (unless custom-fields
+    (return-from inserting-custom-fields (values proc (constantly nil))))
+  (multiple-value-bind (posned-customs end-customs)
+      (partition custom-fields #'consp)
+    (setf posned-customs (stable-sort posned-customs #'< :key #'car))
+    (let ((posn -1))
+      (labels ((custom-field->field-info (custom-field)
+		 (etypecase custom-field
+		   (field-info custom-field)
+		   (view-field (make-field-info :field custom-field
+						:object obj
+						:parent-info nil))))
+	       (wrapper (vfield-info)
+		 (incf posn)
+		 (loop while (and posned-customs
+				  (<= (caar posned-customs) posn))
+		       do (funcall proc (custom-field->field-info
+					 (cdr (pop posned-customs))))
+			  (incf posn))
+		 (funcall proc vfield-info)))
+	(values #'wrapper
+		(f0 (mapc (compose #'wrapper #'custom-field->field-info)
+			  end-customs)
+		    (mapc (compose proc #'custom-field->field-info #'cdr)
+			  posned-customs)))))))
+
+(defun %map-object-view-fields (proc obj view-designator
+				&key include-invisible-p (expand-mixins t)
+				custom-fields &allow-other-keys)
+  "Implement `get-object-view-fields', except for consing up the
+result list, instead calling PROC on each resulting `field-info'."
+  (labels ((map-level-fields (proc view)
+	     (let ((view (or (and view (find-view view))
+			     (return-from map-level-fields))))
+	       (map-level-fields proc (view-inherit-from view))
+	       (dolist (vfield (view-fields view))
+		 (funcall proc vfield))))
+	   (map-level (obj view mixin-container)
+	     (let ((vfields (make-hash-table :test 'eq)))
+	       ;; prefer latest
+	       (map-level-fields
+		(f_ (setf (gethash (view-field-slot-name _) vfields) _))
+		view)
+	       (map-level-fields
+		(lambda (vfield)
+		  ;; we only use the in-order vfield as a tag into the
+		  ;; vfields HT, taking first-instance-only
+		  (setf vfield (gethash (view-field-slot-name vfield) vfields))
+		  (when vfield
+		    (let ((vfield-info (make-field-info
+					:field vfield :object obj
+					:parent-info mixin-container)))
+		      (etypecase vfield
+			(inline-view-field
+			   (when (or include-invisible-p
+				     (not (view-field-hide-p vfield)))
+			     (funcall proc vfield-info)))
+			(mixin-view-field
+			   (if expand-mixins
+			       (map-level
+				(and obj
+				     (or (obtain-view-field-value vfield obj)
+					 (funcall (mixin-view-field-init-form vfield))))
+				(mixin-view-field-view vfield) vfield-info)
+			       (funcall proc vfield-info)))))
+		    ;; avoid duplicates
+		    (remhash (view-field-slot-name vfield) vfields)))
+		view))))
+    (multiple-value-bind (wproc terminate-proc)
+	(inserting-custom-fields obj proc custom-fields)
+      (setf proc wproc)
+      (map-level obj view-designator nil)
+      (funcall terminate-proc))))
+
 (defun get-object-view-fields (obj view-designator &rest args
 			       &key include-invisible-p (expand-mixins t) custom-fields
 			       &allow-other-keys)
@@ -54,128 +133,48 @@
 Each custom field can be either a field-info structure or a
 view-field. Field-info structures are inserted as is, and view-fields
 are wrapped in field-info structures with common-sense defaults."
-  (declare (ignore args))
-  (labels ((compute-view-field-info-list  (view-designator obj parent-field-info)
-	     "Computes a full list of view fields, including inherited
-	     fields. Returns a list of field-infos."
-	     (let ((view (when view-designator
-			   (find-view view-designator))))
-	       (when view
-		 (append (compute-view-field-info-list
-			  (view-inherit-from view) obj
-			  parent-field-info)
-			 (mapcar (lambda (field)
-				   (make-field-info :field field :object obj
-						    :parent-info parent-field-info))
-				 (view-fields view))))))
-	   (factor-overriden-fields (field-info-list)
-	     "Overrides parent fields redefined in children."
-             ;(format t "fil: ~S~%" field-info-list)
-             (flet ((field-key (field-info &aux (field (field-info-field field-info)))
-                      (cons (view-field-slot-name field) (awhen (field-info-parent-info field-info)
-                                                              (view-field-slot-name (field-info-field IT)))))
-                    (parent (field-info &aux (field (field-info-field field-info)))
-                      (field-info-parent-info field-info))
-                    (mixin-p (field-info &aux (field (field-info-field field-info)))
-                      (typep field 'mixin-view-field)))
-               ;(format t "in: ~S~%" (mapcar (compose #'describe #'field-info-field) field-info-list))
-               (let* ((fields (remove-duplicates field-info-list :key #'field-key :from-end nil))
-                      (true-inline-fields (remove-duplicates fields :test #'equal
-                                                             :key (compose #'view-field-slot-name #'field-info-field)
-                                                             :from-end nil))
-                      (true-inline-fields (remove-if (lambda (fi) (or (parent fi) (mixin-p fi))) true-inline-fields
-                                                     :from-end t))
-                      (expanded-mixin-fields (remove-if-not (lambda (fi) (or (parent fi) (mixin-p fi)))
-                                                            fields))
-                      (expanded-mixin-fields (remove-duplicates expanded-mixin-fields :test #'equal :key #'field-key))
-                      (expanded-mixin-fields (remove-if (curry-after #'find true-inline-fields
-                                                                     :test #'equal :key (compose #'view-field-slot-name
-                                                                                                 #'field-info-field)
-                                                                     :from-end nil) expanded-mixin-fields))
-                      (merged-fields (sort (union true-inline-fields expanded-mixin-fields)
-                                           #'< :key (lambda (field)
-                                                      (flet ((pos (field where)
-                                                               (let ((r (position (field-key field) where :key #'field-key :test #'equal)))
-                                                               ;(format t "field: ~S / where: ~S -> ~S%" (field-key field)
-                                                               ;        (mapcar #'field-key where) r)
-                                                               r
-                                                               )))
-                                                        (let ((result (or (pos field fields)
-                                                                          (pos field true-inline-fields)
-                                                                          (pos field expanded-mixin-fields)
-                                                                          0)))
-                                                        #+(or)(format t "result for field ~A: ~A~%" field result) result))))))
-                 ;(format t "true inline: ~S~%" (mapcar #'field-key true-inline-fields))
-                 ;(format t "expanded ~S~%" (mapcar #'field-key expanded-mixin-fields))
-                 ;(format t "fields ~S~%" (mapcar #'field-key fields))
-                 ;(format t "merged ~S~%" (mapcar (compose #'describe #'field-info-field) merged-fields))
-                 merged-fields))) ; XXX this is quite inefficient (at least n^2 + n*log(n))
-	   (expand-mixin-fields (field-info-list)
-	     "Expands mixin fields into inline fields. Returns two
-              values - a list of expanded field-infos, and true if at
-              least one field has been expanded."
-	     (apply #'append
-		    (mapcar (lambda (field-info)
-			      (let ((field (field-info-field field-info))
-				    (obj (field-info-object field-info)))
-				(etypecase field
-				  (inline-view-field (list field-info))
-				  (mixin-view-field (when (or include-invisible-p
-							      (not (view-field-hide-p field)))
-						      (compute-view-field-info-list
-						       (mixin-view-field-view field)
-						       (when obj
-							 (or (obtain-view-field-value field obj)
-							     (funcall (mixin-view-field-init-form field))))
-						       field-info))))))
-			    field-info-list)))
-	   (custom-field->field-info (custom-field)
-	     (etypecase custom-field
-	       (field-info custom-field)
-	       (view-field (make-field-info :field custom-field
-					    :object obj
-					    :parent-info nil)))))
-    (let* ((initial-step (factor-overriden-fields
-			  (compute-view-field-info-list view-designator obj nil)))
-	   (results
-	    (if expand-mixins
-		(loop for field-info-list = initial-step
-		   then (factor-overriden-fields
-			 (expand-mixin-fields field-info-list))
-		   until (notany (lambda (field-info)
-				   (typep (field-info-field field-info) 'mixin-view-field))
-				 field-info-list)
-		   finally (return (if include-invisible-p
-				       field-info-list
-				       (remove-if #'view-field-hide-p field-info-list
-						  :key #'field-info-field))))
-		initial-step)))
-      (dolist (custom-field custom-fields results)
-	(if (consp custom-field)
-	    (insert-at (custom-field->field-info (cdr custom-field)) results (car custom-field))
-	    (push-end (custom-field->field-info custom-field) results))))))
+  (declare (ignore include-invisible-p expand-mixins custom-fields))
+  (let ((expansion '()))
+    (apply #'%map-object-view-fields
+	   (f_ (push _ expansion)) obj view-designator args)
+    (nreverse expansion)))
 
-(defun map-view-fields (fn view obj &rest args &key include-invisible-p custom-fields
-			&allow-other-keys)
+(defun map-view-fields (fn view obj &rest args)
   "Acts like mapcar for view fields. FN should expect a structure of
 type field-info."
-  (declare (ignore args))
-  (mapcar fn (get-object-view-fields obj view
-				     :include-invisible-p include-invisible-p
-				     :custom-fields custom-fields)))
+  (let ((expansion '()))
+    (apply #'%map-object-view-fields
+	   (f_ (push (funcall fn _) expansion)) obj view args)
+    (nreverse expansion)))
 
-(defun map-mixin-fields (fn view obj &rest args)
-  (mapc fn (remove-if
-	    (lambda (field-info)
-	      (not (typep (field-info-field field-info) 'mixin-view-field)))
-	    (apply #'get-object-view-fields obj view
-		   :expand-mixins nil args))))
+(defun find-field-info (name view obj &rest govf-args)
+  "Finds a field-info object by name and returns it."
+  (let (field)
+    (apply #'map-view-fields
+	   (lambda (fi)
+	     (when (equalp (view-field-slot-name (field-info-field fi))
+			   name)
+	       (setf field fi)))
+	   view obj govf-args)
+    field))
 
-(defun count-view-fields (view &key include-invisible-p custom-fields)
+(defun find-view-field (&rest args)
+  (let ((field-info (apply #'find-field-info args)))
+    (when field-info
+      (field-info-field field-info))))
+
+(defun map-mixin-fields (fn view obj &rest govf-args)
+  (apply #'%map-object-view-fields
+	 (lambda (field-info)
+	   (when (typep (field-info-field field-info) 'mixin-view-field)
+	     (funcall fn field-info)))
+	 obj view :expand-mixins nil govf-args))
+
+(defun count-view-fields (view &rest govf-args)
   "Counts the number of fields in a given view."
-  (length (get-object-view-fields nil view
-				  :include-invisible-p include-invisible-p
-				  :custom-fields custom-fields)))
+  (let ((count 0))
+    (apply #'%map-object-view-fields (f_% (incf count)) nil view govf-args)
+    count))
 
 (defun slot-reader (class slot-name)
   "Returns a reader, if one is defined, on the slot."
@@ -268,6 +267,14 @@
      presentation))
    "-presentation"))
 
+(defmethod attributize-view-field-name ((field-info field-info))
+  "Attributize a view field name from its FIELD-INFO structure."
+  (let ((parent-prefix (awhen (field-info-parent-info field-info)
+                              (view-field-slot-name (field-info-field it))))
+        (name (view-field-slot-name (field-info-field field-info))))
+    (when name
+      (attributize-name (format nil "~@[~A-~]~A" parent-prefix name)))))
+
 (defmethod print-object ((obj field-info) stream)
   (flet ((field-key (field-info &aux (field (field-info-field field-info)))
                     (cons (view-field-slot-name field) (awhen (field-info-parent-info field-info)
# HG changeset patch
# User nunb <nunb@tallinn>
# Date 1258906788 -3600
# Node ID a25c651e29011a88d24756230ea633461ab9c9eb
# Parent  ba5a806c2b82b272af31b3e2df3b05dec1783c75
Minor things mostly: allow multiple dialogs, add rel attribute, and bring in jwr's version of form view utils from latest weblocks-dev

diff -r ba5a806c2b82 -r a25c651e2901 src/control-flow/dialog.lisp
--- a/src/control-flow/dialog.lisp	Thu Nov 05 11:35:21 2009 +0100
+++ b/src/control-flow/dialog.lisp	Sun Nov 22 17:19:48 2009 +0100
@@ -78,15 +78,16 @@
 (defun/cc do-dialog (title callee &key css-class close)
   (declare (special *on-ajax-complete-scripts*))
   (if (ajax-request-p)
-      (prog2
-	  (when (current-dialog)
-	    (error "Multiple dialogs not allowed."))
-	  (call callee (lambda (new-callee)
+      (cond
+	  ((current-dialog)
+	    (warn "Multiple dialogs not allowed."))
+	  (t
+	   (call callee (lambda (new-callee)
 			 (setf (current-dialog) (make-dialog :title title
 							     :widget new-callee
 							     :close close
 							     :css-class css-class))
-                         (send-script (ps* (make-dialog-js title new-callee css-class close)))))
+                         (send-script (ps* (make-dialog-js title new-callee css-class close))))))
 	(setf (current-dialog) nil)
         (send-script (ps (remove-dialog))))
       (do-modal title callee :css-class css-class)))
diff -r ba5a806c2b82 -r a25c651e2901 src/snippets/html-utils.lisp
--- a/src/snippets/html-utils.lisp	Thu Nov 05 11:35:21 2009 +0100
+++ b/src/snippets/html-utils.lisp	Sun Nov 22 17:19:48 2009 +0100
@@ -253,10 +253,10 @@
     (:span :class "close-button"
 	   (render-link close-action (humanize-name button-string)))))
 
-(defun render-input-field (type name value &key id class maxlength style)
+(defun render-input-field (type name value &key id class maxlength style rel)
   (with-html
     (:input :type type :name (attributize-name name) :id id
-	    :value value :maxlength maxlength :class class
+	    :value value :maxlength maxlength :class class :rel rel
             :style style)))
 
 (defun render-password (name value &key (id (gen-id)) (class "password") maxlength style
diff -r ba5a806c2b82 -r a25c651e2901 src/views/view/utils.lisp
--- a/src/views/view/utils.lisp	Thu Nov 05 11:35:21 2009 +0100
+++ b/src/views/view/utils.lisp	Sun Nov 22 17:19:48 2009 +0100
@@ -3,9 +3,10 @@
 
 (export '(find-view field-info field-info-field field-info-object
 	  field-info-path get-object-view-fields map-view-fields
-	  map-mixin-fields count-view-fields obtain-view-field-value
-	  render-object-view class-from-view render-view
-	  render-object-view-impl attributize-presentation))
+	  find-field-info find-view-field map-mixin-fields
+	  count-view-fields obtain-view-field-value render-object-view
+	  class-from-view render-view render-object-view-impl
+	  attributize-presentation attributize-view-field-name))
 
 ;;; View rendering utils
 (defun find-view (view &optional (signal-error-p t))
@@ -33,6 +34,84 @@
 if it was mixed into the view."
   field object parent-info)
 
+(defun inserting-custom-fields (obj proc custom-fields)
+  "Wrap PROC, a `map-view-fields' candidate, with a variant that
+inserts each of CUSTOM-FIELDS as defined by `get-object-view-fields'.
+Secondary, answer a termination thunk."
+  (unless custom-fields
+    (return-from inserting-custom-fields (values proc (constantly nil))))
+  (multiple-value-bind (posned-customs end-customs)
+      (partition custom-fields #'consp)
+    (setf posned-customs (stable-sort posned-customs #'< :key #'car))
+    (let ((posn -1))
+      (labels ((custom-field->field-info (custom-field)
+		 (etypecase custom-field
+		   (field-info custom-field)
+		   (view-field (make-field-info :field custom-field
+						:object obj
+						:parent-info nil))))
+	       (wrapper (vfield-info)
+		 (incf posn)
+		 (loop while (and posned-customs
+				  (<= (caar posned-customs) posn))
+		       do (funcall proc (custom-field->field-info
+					 (cdr (pop posned-customs))))
+			  (incf posn))
+		 (funcall proc vfield-info)))
+	(values #'wrapper
+		(f0 (mapc (compose #'wrapper #'custom-field->field-info)
+			  end-customs)
+		    (mapc (compose proc #'custom-field->field-info #'cdr)
+			  posned-customs)))))))
+
+(defun %map-object-view-fields (proc obj view-designator
+				&key include-invisible-p (expand-mixins t)
+				custom-fields &allow-other-keys)
+  "Implement `get-object-view-fields', except for consing up the
+result list, instead calling PROC on each resulting `field-info'."
+  (labels ((map-level-fields (proc view)
+	     (let ((view (or (and view (find-view view))
+			     (return-from map-level-fields))))
+	       (map-level-fields proc (view-inherit-from view))
+	       (dolist (vfield (view-fields view))
+		 (funcall proc vfield))))
+	   (map-level (obj view mixin-container)
+	     (let ((vfields (make-hash-table :test 'eq)))
+	       ;; prefer latest
+	       (map-level-fields
+		(f_ (setf (gethash (view-field-slot-name _) vfields) _))
+		view)
+	       (map-level-fields
+		(lambda (vfield)
+		  ;; we only use the in-order vfield as a tag into the
+		  ;; vfields HT, taking first-instance-only
+		  (setf vfield (gethash (view-field-slot-name vfield) vfields))
+		  (when vfield
+		    (let ((vfield-info (make-field-info
+					:field vfield :object obj
+					:parent-info mixin-container)))
+		      (etypecase vfield
+			(inline-view-field
+			   (when (or include-invisible-p
+				     (not (view-field-hide-p vfield)))
+			     (funcall proc vfield-info)))
+			(mixin-view-field
+			   (if expand-mixins
+			       (map-level
+				(and obj
+				     (or (obtain-view-field-value vfield obj)
+					 (funcall (mixin-view-field-init-form vfield))))
+				(mixin-view-field-view vfield) vfield-info)
+			       (funcall proc vfield-info)))))
+		    ;; avoid duplicates
+		    (remhash (view-field-slot-name vfield) vfields)))
+		view))))
+    (multiple-value-bind (wproc terminate-proc)
+	(inserting-custom-fields obj proc custom-fields)
+      (setf proc wproc)
+      (map-level obj view-designator nil)
+      (funcall terminate-proc))))
+
 (defun get-object-view-fields (obj view-designator &rest args
 			       &key include-invisible-p (expand-mixins t) custom-fields
 			       &allow-other-keys)
@@ -54,128 +133,48 @@
 Each custom field can be either a field-info structure or a
 view-field. Field-info structures are inserted as is, and view-fields
 are wrapped in field-info structures with common-sense defaults."
-  (declare (ignore args))
-  (labels ((compute-view-field-info-list  (view-designator obj parent-field-info)
-	     "Computes a full list of view fields, including inherited
-	     fields. Returns a list of field-infos."
-	     (let ((view (when view-designator
-			   (find-view view-designator))))
-	       (when view
-		 (append (compute-view-field-info-list
-			  (view-inherit-from view) obj
-			  parent-field-info)
-			 (mapcar (lambda (field)
-				   (make-field-info :field field :object obj
-						    :parent-info parent-field-info))
-				 (view-fields view))))))
-	   (factor-overriden-fields (field-info-list)
-	     "Overrides parent fields redefined in children."
-             ;(format t "fil: ~S~%" field-info-list)
-             (flet ((field-key (field-info &aux (field (field-info-field field-info)))
-                      (cons (view-field-slot-name field) (awhen (field-info-parent-info field-info)
-                                                              (view-field-slot-name (field-info-field IT)))))
-                    (parent (field-info &aux (field (field-info-field field-info)))
-                      (field-info-parent-info field-info))
-                    (mixin-p (field-info &aux (field (field-info-field field-info)))
-                      (typep field 'mixin-view-field)))
-               ;(format t "in: ~S~%" (mapcar (compose #'describe #'field-info-field) field-info-list))
-               (let* ((fields (remove-duplicates field-info-list :key #'field-key :from-end nil))
-                      (true-inline-fields (remove-duplicates fields :test #'equal
-                                                             :key (compose #'view-field-slot-name #'field-info-field)
-                                                             :from-end nil))
-                      (true-inline-fields (remove-if (lambda (fi) (or (parent fi) (mixin-p fi))) true-inline-fields
-                                                     :from-end t))
-                      (expanded-mixin-fields (remove-if-not (lambda (fi) (or (parent fi) (mixin-p fi)))
-                                                            fields))
-                      (expanded-mixin-fields (remove-duplicates expanded-mixin-fields :test #'equal :key #'field-key))
-                      (expanded-mixin-fields (remove-if (curry-after #'find true-inline-fields
-                                                                     :test #'equal :key (compose #'view-field-slot-name
-                                                                                                 #'field-info-field)
-                                                                     :from-end nil) expanded-mixin-fields))
-                      (merged-fields (sort (union true-inline-fields expanded-mixin-fields)
-                                           #'< :key (lambda (field)
-                                                      (flet ((pos (field where)
-                                                               (let ((r (position (field-key field) where :key #'field-key :test #'equal)))
-                                                               ;(format t "field: ~S / where: ~S -> ~S%" (field-key field)
-                                                               ;        (mapcar #'field-key where) r)
-                                                               r
-                                                               )))
-                                                        (let ((result (or (pos field fields)
-                                                                          (pos field true-inline-fields)
-                                                                          (pos field expanded-mixin-fields)
-                                                                          0)))
-                                                        #+(or)(format t "result for field ~A: ~A~%" field result) result))))))
-                 ;(format t "true inline: ~S~%" (mapcar #'field-key true-inline-fields))
-                 ;(format t "expanded ~S~%" (mapcar #'field-key expanded-mixin-fields))
-                 ;(format t "fields ~S~%" (mapcar #'field-key fields))
-                 ;(format t "merged ~S~%" (mapcar (compose #'describe #'field-info-field) merged-fields))
-                 merged-fields))) ; XXX this is quite inefficient (at least n^2 + n*log(n))
-	   (expand-mixin-fields (field-info-list)
-	     "Expands mixin fields into inline fields. Returns two
-              values - a list of expanded field-infos, and true if at
-              least one field has been expanded."
-	     (apply #'append
-		    (mapcar (lambda (field-info)
-			      (let ((field (field-info-field field-info))
-				    (obj (field-info-object field-info)))
-				(etypecase field
-				  (inline-view-field (list field-info))
-				  (mixin-view-field (when (or include-invisible-p
-							      (not (view-field-hide-p field)))
-						      (compute-view-field-info-list
-						       (mixin-view-field-view field)
-						       (when obj
-							 (or (obtain-view-field-value field obj)
-							     (funcall (mixin-view-field-init-form field))))
-						       field-info))))))
-			    field-info-list)))
-	   (custom-field->field-info (custom-field)
-	     (etypecase custom-field
-	       (field-info custom-field)
-	       (view-field (make-field-info :field custom-field
-					    :object obj
-					    :parent-info nil)))))
-    (let* ((initial-step (factor-overriden-fields
-			  (compute-view-field-info-list view-designator obj nil)))
-	   (results
-	    (if expand-mixins
-		(loop for field-info-list = initial-step
-		   then (factor-overriden-fields
-			 (expand-mixin-fields field-info-list))
-		   until (notany (lambda (field-info)
-				   (typep (field-info-field field-info) 'mixin-view-field))
-				 field-info-list)
-		   finally (return (if include-invisible-p
-				       field-info-list
-				       (remove-if #'view-field-hide-p field-info-list
-						  :key #'field-info-field))))
-		initial-step)))
-      (dolist (custom-field custom-fields results)
-	(if (consp custom-field)
-	    (insert-at (custom-field->field-info (cdr custom-field)) results (car custom-field))
-	    (push-end (custom-field->field-info custom-field) results))))))
+  (declare (ignore include-invisible-p expand-mixins custom-fields))
+  (let ((expansion '()))
+    (apply #'%map-object-view-fields
+	   (f_ (push _ expansion)) obj view-designator args)
+    (nreverse expansion)))
 
-(defun map-view-fields (fn view obj &rest args &key include-invisible-p custom-fields
-			&allow-other-keys)
+(defun map-view-fields (fn view obj &rest args)
   "Acts like mapcar for view fields. FN should expect a structure of
 type field-info."
-  (declare (ignore args))
-  (mapcar fn (get-object-view-fields obj view
-				     :include-invisible-p include-invisible-p
-				     :custom-fields custom-fields)))
+  (let ((expansion '()))
+    (apply #'%map-object-view-fields
+	   (f_ (push (funcall fn _) expansion)) obj view args)
+    (nreverse expansion)))
 
-(defun map-mixin-fields (fn view obj &rest args)
-  (mapc fn (remove-if
-	    (lambda (field-info)
-	      (not (typep (field-info-field field-info) 'mixin-view-field)))
-	    (apply #'get-object-view-fields obj view
-		   :expand-mixins nil args))))
+(defun find-field-info (name view obj &rest govf-args)
+  "Finds a field-info object by name and returns it."
+  (let (field)
+    (apply #'map-view-fields
+	   (lambda (fi)
+	     (when (equalp (view-field-slot-name (field-info-field fi))
+			   name)
+	       (setf field fi)))
+	   view obj govf-args)
+    field))
 
-(defun count-view-fields (view &key include-invisible-p custom-fields)
+(defun find-view-field (&rest args)
+  (let ((field-info (apply #'find-field-info args)))
+    (when field-info
+      (field-info-field field-info))))
+
+(defun map-mixin-fields (fn view obj &rest govf-args)
+  (apply #'%map-object-view-fields
+	 (lambda (field-info)
+	   (when (typep (field-info-field field-info) 'mixin-view-field)
+	     (funcall fn field-info)))
+	 obj view :expand-mixins nil govf-args))
+
+(defun count-view-fields (view &rest govf-args)
   "Counts the number of fields in a given view."
-  (length (get-object-view-fields nil view
-				  :include-invisible-p include-invisible-p
-				  :custom-fields custom-fields)))
+  (let ((count 0))
+    (apply #'%map-object-view-fields (f_% (incf count)) nil view govf-args)
+    count))
 
 (defun slot-reader (class slot-name)
   "Returns a reader, if one is defined, on the slot."
@@ -268,6 +267,14 @@
      presentation))
    "-presentation"))
 
+(defmethod attributize-view-field-name ((field-info field-info))
+  "Attributize a view field name from its FIELD-INFO structure."
+  (let ((parent-prefix (awhen (field-info-parent-info field-info)
+                              (view-field-slot-name (field-info-field it))))
+        (name (view-field-slot-name (field-info-field field-info))))
+    (when name
+      (attributize-name (format nil "~@[~A-~]~A" parent-prefix name)))))
+
 (defmethod print-object ((obj field-info) stream)
   (flet ((field-key (field-info &aux (field (field-info-field field-info)))
                     (cons (view-field-slot-name field) (awhen (field-info-parent-info field-info)
